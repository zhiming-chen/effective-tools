



#  R语言基础
---
> 这部分内容之前在其他栏目里写过，后续会逐步搬运到这个文件中来


---



#  算法基础及案例
---

> 学习掌握算法基础，并在R语言中实现。
> 因为R语言在很多算法问题上做不到像C，java 甚至Python那样灵活，所以，这部分会是一些入门级别的简单算法案例。


---
##  W1D1 质数判断--初步认识选择、判断与循环


---

##  W1D2 最大公约数--初步认识循环与递归

---

##  W1D3 Hanoi 塔问题-- 递归算法的初识
---


###  递归的本质是“自我调用”

递归算法的核心思想是：
 
> 把一个**大问题**，逐步**分解成规模更小的相同问题**，直到可以用**直接答案**解决的**最小问题**为止。


###   汉诺塔问题概述

> 给定三根柱子 A、B、C，把 N 个大小不同的圆盘从 A 移到 C，每次只能移动一个，且**大盘不能叠在小盘上**。


###   递归思想分析

对于 `n` 个盘子（编号从大到小为 n, n-1, ..., 1）：

1. **把前 n-1 个盘子** 从 A 移到 B（借助 C）→ 递归①
    
2. **把第 n 个盘子** 从 A 移到 C（一步）
    
3. **把前 n-1 个盘子** 从 B 移到 C（借助 A）→ 递归②


###   可视化递归流程（n=3）：

```
 hanoi(3, A, C, B)    # 表示把3个盘子从A搬到C，用B作为辅助
├── hanoi(2, A, B, C)
│   ├── hanoi(1, A, C, B)
│   └── Move disk 2 from A to B
│   └── hanoi(1, C, B, A)
├── Move disk 3 from A to C
└── hanoi(2, B, C, A)
    ├── hanoi(1, B, A, C)
    └── Move disk 2 from B to C
    └── hanoi(1, A, C, B)
    
```


---

###   R语言实现

```

hanoi <- function(n, from = "A", to = "C", aux = "B") {
  if (n == 1) {
    cat(sprintf("Move disk 1 from %s to %s\n", from, to))
  } else {
    hanoi(n - 1, from, aux, to)                       # 步骤①
    cat(sprintf("Move disk %d from %s to %s\n", n, from, to))  # 步骤②
    hanoi(n - 1, aux, to, from)                       # 步骤③
  }
}


```

###   运行示例

```
hanoi(3)

Move disk 1 from A to C
Move disk 2 from A to B
Move disk 1 from C to B
Move disk 3 from A to C
Move disk 1 from B to A
Move disk 2 from B to C
Move disk 1 from A to C

```




##  W1D4 Fibonacci 斐波那契数列--递归算法初始与替换

###  斐波那契数列简介

+ 数列的前两项分别为0,1
+ 从第三项开始，每项数值为其前两项数值之和，如第三项为1，第四项为1+1=2，第五项为1+2 = 3，第六项等于2+3 =5...
+ f(0) =0,f(1)=1,f(n) =f(n-1) + f(n-2) (n>=3)

### 递归思想分析

求斐波那契数列，是一个典型的递归算法问题。对于一个长度为`n`的数列{$ x_1, x_2,x_3....x_(n-1),x_n $}

### R语言实现

```

fibonacci_1  <- function(n){
    if (!is.numeric(n) || n %% 1 != 0 || n < 0) {
        stop("请输入非负整数")}
    
    if(n == 0) return(0)
    if(n == 1) return(1) 
    fibonacci_1(n-1) + fibonacci_1(n-2)
   
}

# fibonacci_1(6)

```

但是，这个算法效率太低了，大量重复计算，指数级的复杂度。比如计算f(5)时，需要计算F(4)和F(3),计算F(4)时又需要计算F(3)和F(2)...大量的重复计算。

可以使用其他方式实现，比如带缓存或循环法。

###  循环法实现

做法其实很简单，F(1)=0,F(2)=1,后面每次计算结果存储起来，作为后面数值的计算输入。

在编程里后续会有大量这样的案例，有些是直接数字替换，有些是存为向量结果。也就是这里提及的缓存的概念。

```

fibonacci_2 <- function(n){
    if (!is.numeric(n) || n %% 1 != 0 || n < 0) {
        stop("请输入非负整数")}
    
    if(n == 0) return(0)
    if(n == 1) return(1) 
    
    a <- 0
    b <- 1
    
    
    for(i in 2:n){
        n_fib <- a + b
        a <- b
        b <- n_fib
    }
    
  return(b)    
}

# fibonacci_2(6)

```

### 存储法

```

fibonacci_3 <- function(n){
    if (!is.numeric(n) || n %% 1 != 0 || n < 0) {
        stop("请输入非负整数")}
    
    if(n == 0) return(0)
    if(n == 1) return(1) 
 
    #创建一个长度为n+1的向量
 fi_v <- numeric(n+1)
 fi_v[1] <- 0  # 这里存放F(0)
 fi_v[2] <- 1  # 这里存放F(1)
 
 for (i in 3:(n+1)){# 这里n+1 需要括起来...
     fi_v[i] <- fi_v[i-1] + fi_v[i-2]
 }
 return(list(fi_v[n+1], fi_v))
 
}
# 和很多其他编程语言不一样，R语言向量第一位用数字1表示，不是其他语言多用的0    
    
# fibonacci_3(6)

```

这里的迭代法与缓存法，在后续的编程中会大量出现。


##  W1D5 返回 1 到 n 的所有质数

本节使用W1D1写的`is_prme`函数来实现质数的查找来实践：
+ 数据储存到向量
+ for循环
+ apply系列循环初识
+ map循环初识
+ 向量化编程思维初启...

### 实现步骤概述如下

+ 调用自己写的函数：`source`函数实现
+ 对数据对象循环实施is_prime函数
+ 常用的三种方法下文分别列出

#### for 循环 + 向量存储

+ 函数输入为数字n, 
+ 函数实现从1到n中全部质数的查找
+ 这些质数存储到一个向量
+ 函数的输出为这个向量
+ 首先创建一个空向量
+ 对1:n之间的数值用is_prime函数进行遍历，结果为TRUE 时存入空向量，结果为false不存，直到n为止。
举例：
+ 先创建一个空向量p <- c()
+ 对于数值2，他是质数，所以向量就变成了p  : c(p, 2), 结束，继续下一步
+ 对于数值3，他也是质数，所以向量就变成了p :c(p,2,3)...
+ 因为初始p为空向量，所以最后就实现了目标数值的存储。

```

# for 循环 + 向量存储

get_prime_for <- function(n){
    # 目标位找到1到n之间的全部质数
    
    if (!(is.numeric(n) && n > 1 && n %% 1 == 0)) {
        stop("请输入大于1的整数")
    }
    
    primes <- c()
    
    for(i in 2:n){# 因为1不是质数，所以不纳入
        
        if(is_prime_for(i)){ # 调用的函数，他的输出是TRUE|FALSE 的逻辑值
            
            primes <- c(primes,i)
        }
     
    }
    
    return(primes)   # 不能写在for循环里，否则他会直接在第一步就结束for循环
}


# get_prime_for(19)

```



#### 输入向量+apply系列函数循环 + 向量输出

+ 数字n作为输入
+ 根据数字n生成1,2,3...n构成的向量
+ 使用apply函数对这个向量遍历is_prime函数，对向量元素进行判断T|F
+ 提取全部T向量元素，形成向量，作为函数的输出

```

get_prime_apply <- function(n){
    
    
    
    # 目标位找到1到n之间的全部质数
    
    if (!(is.numeric(n) && n > 1 && n %% 1 == 0)) {
        stop("请输入大于1的整数")
    }
    
    vec <- 2:n
    
    vec[sapply(vec,is_prime_for)]
     
    }
    


# get_prime_apply(19)

```

#### 输入向量+map循环 + 向量输出

简单记录map循环

```
## map 循环

get_prime_map <- function(n){
    
    
    
    # 目标位找到1到n之间的全部质数
    
    if (!(is.numeric(n) && n > 1 && n %% 1 == 0)) {
        stop("请输入大于1的整数")
    }
    
    vec <- 2:n
    
    vec[purrr::map_lgl(vec,is_prime_for)]
    
}

# get_prime_map(19)


```

总结，这是一个很基础，但对理解R语言循环编程，以及提取向量元素，存储向量元素等基础操作有帮助。




##  W2D6 找出一个数的全部因数

这是一个很简单的问题，学习计划里有这么一个题目，所以就记录于此。

### 实现步骤

+ 与判断一个数是否为质数的方法类似，找一个数的因数，可以用这个数本身除以其开根后的自然数以内的各个数，如余数为0，则除数和结果均为其因数；如余数不为0，则继续下一个数，直到循环结束。

+ 举例：数111,先开根号，得到数10，用111一次除以2到10（1不用参与，因为1和本身肯定都是一个数的因数），除以2，余数为1，2 不是；除以3，余数为0，商为37，后面依次除以4...10余数不为0；所以111的全部因数为（1,3,37,111）
+ 当一个数是平方数时，如25，开根后的那个数在因数里只出现一次，也就是当除数等于商时，只放一个数金数组向量，避免重复。


### for 循环 + 向量存储

+ 函数输入为数字n, 
+ 函数实现找到数字n的全部因数，并以向量的形式输出
+ 这些因数存储到一个向量
+ 函数的输出为这个向量
+ 首先创建一个向量，这个向量包含数值1以及输入数值n
+ 数值n依次除以1:sqrt(n)之间的自然数，能整除的，对应数值及其商装入向量中； 不能整除的继续下一个数，直到sqrt(n)为止。
```

get_factor <- function(n){
    # 目标位找到1到n之间的全部质数
    
    if (!(is.numeric(n) && n > 1 && n %% 1 == 0)) {
        stop("请输入大于1的整数")
    }
    
    factor_vec <- c(1,n)
    
    k <- floor(sqrt(n))
    
    for(i in 2:k){# 因为1和数字本身肯定是数字的因数
        
        if(n %% i == 0){ # 调用的函数，他的输出是TRUE|FALSE 的逻辑值
            q <- n/i
            factor_vec <- c(factor_vec,i,q)
        }
        
    }
    factor_vec <- unique(factor_vec) ## 去重
    
    factor_vec <- sort(factor_vec) ## 排序
    
    return(factor_vec)  
}


# get_factor(100)

```

##  W2D7 凑零钱问题

### 问题描述

这是一个经典算法题。

给定不同面额的硬币，也就是零钱，以及一个总金额。假定每个面额的零钱是取之不尽的；

需要编写一个函数来计算凑成总金额的最少硬币个数。如果没有任何一种组合能够凑齐，则返回-1.


### 算法说明

这是一个典型的动态规划类问题。
+ 不同面额的硬币，我们定义一个数值向量**coins** = c（c1,c2,c3...);
+ 总金额：**amount**
+ **dp[i]** : 总面值为i时所需**最小**硬币数 

使用**自底向上**的动态规划方法来求解决该问题。 

当amount 值小于min（coins）值时，显然，是无解的。

考虑可凑齐的情形，对于coins中的硬币，比如c1,
我们想凑齐总金额i，可以在最后放入c1这个硬币，那么问题就转化为凑齐(i-c1)所需的硬币数，因为只要这个数字出来了，我再加上c1这个硬币，就是凑齐金额i所需的硬币数了；那我们可以写成dp[i] = dp[i-c1]+1；

同样地，对于c2,c3...coins 中各面值的硬币，都能得到对应的公式；

那么，我们只需要求出最后放入不同面值硬币所需的硬币数的**最小值**就能得到最终结果了。

可得到 dp[i]=min(dp[i−coins]+1)这一状态转移公式。


#### 实现步骤

+ dp[0] = 0
+ 从1 开始，从小到大遍历到金额amount
+ 逐级取得dp[i] 最小值
+ 最后得到最小结果。

#### 举例说明

+ 给定硬币面额为1,2,5三种
+ 总金额为11
+ coins = c(1, 2, 5)，amount = 11

我们依次求出 dp[1] 到 dp[11]：

| i   | dp[i - 1] + 1 | dp[i - 2] + 1 | dp[i - 5] + 1 | dp[i] 最小值 |
| --- | ------------- | ------------- | ------------- | --------- |
| 1   | 0+1=1         | —             | —             | ✅1        |
| 2   | 1+1=2         | 0+1=1         | —             | ✅1        |
| 3   | 1+1=2         | 1+1=2         | —             | ✅2        |
| 4   | 2+1=3         | 1+1=2         | —             | ✅2        |
| 5   | 2+1=3         | 2+1=34        | 0+1=1         | ✅1        |
| 6   | 1+1=2         | 2+1=3         | 1+1=2         | ✅2        |
| 7   | 2+1=3         | 1+1=2         | 1+1=2         | ✅2        |
| 8   | 2+1=3         | 2+1=3         | 2+1=3         | ✅3        |
| 9   | 3+1=4         | 2+1=3         | 2+1=3         | ✅3        |
| 10  | 3+1=4         | 3+1=4         | 1+1=2         | ✅2        |
| 11  | 2+1=3         | 3+1=4         | 2+1=3         | ✅3        |



解释：

+ 当i =1 时，
	+ 面值为1硬币有解，1个，公式为dp[0] +1 =1,
	+ 面值为2,5的两个无解；
+ 当i =2 时，
	+ 对于面值为1最后放，那么就是df[1]的最小值+1 ，也就是1+1 =2；
	+ 对于面值为2最后放，那么就是df[0]的最小值+1，也就是0+1 =1;
	+ 对于面值为5最后放，结果是不成立
	+ 当i = 2时，最小值为1，也就是**df[2] = 1**

+ 当i =3 时，
	+ 对于面值为1最后放，那么就是df[2]的最小值+1，也就是1+1 =2；
	+ 对于面值为2最后放，那么就是df[1]的最小值+1，也就是1+1 =2;
	+ 对于面值为5最后放，结果是不成立
	+ 当i = 3时，最小值为2，也就是**df[3] = 2**

+ 当i =4 时，
	+ 对于面值为1最后放，那么就是df[3]的最小值+1，也就是2+1 =3；
	+ 对于面值为2最后放，那么就是df[2]的最小值+1，也就是1+1 =2;
	+ 对于面值为5最后放，结果是不成立
	+ 当i = 4时，最小值为2，也就是**df[4] = 2**


+ 当i =5 时，
	+ 对于面值为1最后放，那么就是df[4]的最小值+1，也就是2+1 =3；
	+ 对于面值为2最后放，那么就是df[3]的最小值+1，也就是2+1 =3;
	+ 对于面值为5最后放，那么就是df[0]的最小值+1，也就是0+1 =1;
	+ 当i = 5时，最小值为1，也就是**df[5] = 1**


+ 当i =6 时，
	+ 对于面值为1最后放，那么就是df[5]的最小值+1，也就是1+1 =2；
	+ 对于面值为2最后放，那么就是df[4]的最小值+1，也就是2+1 =3;
	+ 对于面值为5最后放，那么就是df[1]的最小值+1，也就是1+1 =2;
	+ 当i = 6时，最小值为2，也就是**df[6] = 2**


+ 当i =7 时，
	+ 对于面值为1最后放，那么就是df[6]的最小值+1，也就是2+1 =3；
	+ 对于面值为2最后放，那么就是df[5]的最小值+1，也就是1+1 =2;
	+ 对于面值为5最后放，那么就是df[2]的最小值+1，也就是1+1 =2;
	+ 当i = 7时，最小值为2，也就是**df[7] = 2**


+ 当i =8 时，
	+ 对于面值为1最后放，那么就是df[7]的最小值+1，也就是2+1 =3；
	+ 对于面值为2最后放，那么就是df[6]的最小值+1，也就是2+1 =3;
	+ 对于面值为5最后放，那么就是df[3]的最小值+1，也就是2+1 =3;
	+ 当i = 8时，最小值为3，也就是**df[8] = 3**



+ 当i =9 时，
	+ 对于面值为1最后放，那么就是df[8]的最小值+1，也就是3+1 =4；
	+ 对于面值为2最后放，那么就是df[7]的最小值+1，也就是2+1 =3;
	+ 对于面值为5最后放，那么就是df[4]的最小值+1，也就是2+1 =3;
	+ 当i = 9时，最小值为3，也就是**df[9] = 3**


+ 当i =10 时，
	+ 对于面值为1最后放，那么就是df[9]的最小值+1，也就是3+1 =4；
	+ 对于面值为2最后放，那么就是df[8]的最小值+1，也就是3+1 =4;
	+ 对于面值为5最后放，那么就是df[5]的最小值+1，也就是1+1 =2;
	+ 当i = 10时，最小值为2，也就是**df[10] = 2**


+ 当i =11 时，
	+ 对于面值为1最后放，那么就是df[10]的最小值+1，也就是2+1 =3；
	+ 对于面值为2最后放，那么就是df[9]的最小值+1，也就是3+1 =4;
	+ 对于面值为5最后放，那么就是df[6]的最小值+1，也就是3+1 =4;
	+ 当i = 11时，最小值为3，也就是**df[11] = 3**



#### 代码实现

```
# coins 为硬币面值的向量，比如1,2,5...

# amount 为目标总金额，比如11...
# 
# dp[i] 为总金额为i-1所需的最小硬币数

# 先预设dp[1] = 0

# dp[i] = min(dp[i],dp[i-coin] + 1)

# 先顶一个数值向量，来装所需最小硬币数,初始定义每个值均为Inf，意味着每个总额都无解

coins_change <- function(coins,amount){
    
    dp <- rep(Inf, amount+1)
    
    dp[1] <- 0
    
    for (i in 2:(amount + 1)) {
        for(coin in coins){
                  if(coin <=(i - 1)){
                    dp[i] <-  min(dp[i],dp[i-coin] + 1)
                }
            }
            
        }
    if (is.infinite(dp[amount + 1])){
        return(-1)
    } else{
        return(dp[amount + 1])
  }
    
}

# 或者这样，逻辑是一致的


coins_change2 <- function(coins, amount) {
    # 创建dp数组，dp[i]表示组成金额i所需的最少硬币数
    dp <- rep(Inf, amount + 1)
    # 金额为0时，需要0个硬币
    dp[1] <- 0  # 对应金额0
    
    # 填充dp数组
    for (i in 1:amount) {
        for (coin in coins) {
            if (coin <= i) {
                # 状态转移方程
                dp[i + 1] <- min(dp[i + 1], dp[i - coin + 1] + 1)
            }
        }
    }
    
    # 判断是否能组成目标金额
    if (dp[amount + 1] == Inf) {
        return(-1)
    } else {
        return(dp[amount + 1])
    }
}




```


代码说明：

+ 在R语言中，数据索引从1开始；所以dp[1]对应的金额amount值为0，自然，其原始值为0，
+ 依次地，dp[2]对应amount值为2-1,... dp[i]对应amount值为i-1
+ 目标金额amount最小硬币数存储在dp[amount + 1]位置
+ 初始预设dp[i]为无穷大值，然后从0开始，如果能替换，即能替换，否则就保留。
#### 运行示例

1. coins_change(coins = c(1,2,5),amount = 5 ）结果1
简单罗列运行顺序
+ 定义dp = c(Inf, Inf, Inf, Inf, Inf, Inf) 共5 + 1 =6个
+ dp[1] = 0
+ dp = c(0, Inf, Inf, Inf, Inf, Inf)
+ **分别对coin(1,2,5) 确定dp[2]**
	 + coin = 1: 
	 dp[2] <-  min(dp[2],dp[1] + 1),右侧表达式中dp[2] 值为Inf，dp[1] 值为0，所以结果为1，也就是说，此时dp = c(0, 1, Inf, Inf, Inf, Inf)
	+  coin = 2:  按规则，不计算，因为不满足coin <=(i - 1)这个条件
	+  coin = 5：按规则，不计算，因为不满足coin <=(i - 1)这个条件
	循环完coin后，dp确定为：**dp = c(0, 1, Inf, Inf, Inf, Inf)**
	
+ **分别对coin(1,2,5) 确定dp[3]**
	 + coin = 1: 
	 dp[3] <-  min(dp[3],dp[2] + 1),右侧表达式中dp[3] 值为Inf，dp[2] 值为1，所以结果为2，也就是说，此时dp = c(0, 1, 2, Inf, Inf, Inf)
	+  coin = 2:  
	  dp[3] <-  min(dp[3],dp[1] + 1),右侧表达式中dp[3] 值为2，dp[1] 值为0，所以结果为1，也就是说，此时dp = c(0, 1, 1, Inf, Inf, Inf)
	+  coin = 5：按规则，不计算，因为不满足coin <=(i - 1)这个条件
	循环完coin后，dp确定为：**dp = c(0, 1, 1, Inf, Inf, Inf)**

+ **分别对coin(1,2,5) 确定dp[4]**
	 + coin = 1: 
	 dp[4] <-  min(dp[4],dp[3] + 1),右侧表达式中dp[4] 值为Inf，dp[3] 值为1，所以结果为2，也就是说，此时dp = c(0, 1, 1, 2, Inf, Inf)
	+  coin = 2:  
	  dp[4] <-  min(dp[4],dp[2] + 1),右侧表达式中dp[4] 值为2，dp[2] 值为1，所以结果为1，也就是说，此时dp = c(0, 1, 1, 2 Inf, Inf)
	+  coin = 5：按规则，不计算，因为不满足coin <=(i - 1)这个条件
	循环完coin后，dp确定为：**dp = c(0, 1, 1, 2, Inf, Inf)**


+ **分别对coin(1,2,5) 确定dp[5]**
	 + coin = 1: 
	 dp[5] <-  min(dp[5],dp[4] + 1),右侧表达式中dp[5] 值为Inf，dp[4] 值为2，所以结果为3，也就是说，此时dp = c(0, 1, 1, 2, 3, Inf)
	+  coin = 2:  
	  dp[5] <-  min(dp[5],dp[3] + 1),右侧表达式中dp[5] 值为3，dp[3] 值为1，所以结果为2，也就是说，此时dp = c(0, 1, 1, 2 2, Inf)
	+  coin = 5：按规则，不计算，因为不满足coin <=(i - 1)这个条件
	循环完coin后，dp确定为：**dp = c(0, 1, 1, 2, 2 Inf)**


+ **分别对coin(1,2,5) 确定dp[6]**
	 + coin = 1: 
	 dp[6] <-  min(dp[6],dp[5] + 1),右侧表达式中dp[6] 值为Inf，dp[5] 值为2，所以结果为3，也就是说，此时dp = c(0, 1, 1, 2, 3, 3)
	+  coin = 2:  
	  dp[6] <-  min(dp[6],dp[4] + 1),右侧表达式中dp[6] 值为3，dp[4] 值为2，所以结果为3，也就是说，此时dp = c(0, 1, 1, 2 2, 3)
	+  coin = 5：
	 dp[6] <-  min(dp[6],dp[1] + 1),右侧表达式中dp[6] 值为3，dp[1] 值为0，所以结果为1，也就是说，此时dp = c(0, 1, 1, 2 2, 1)
	循环完coin后，dp确定为：**dp = c(0, 1, 1, 2, 2,1)**


至此完成全部循环，当amount=5时，其所需最小硬币数为dp[amount +1] =dp[6] = 1



1. coins_change2(coins = c(5,8),amount = 7) 结果-1，即无解
